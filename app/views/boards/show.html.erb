<div class="row">
  <div class="col-md-8">
    <h1><%= @board.name %></h1>
    <div class="mb-3">
      <p class="text-muted mb-1">Created by: <strong><%= @board.email %></strong></p>
      <p class="text-muted mb-1">Created at: <%= @board.created_at.strftime("%B %d, %Y at %I:%M %p") %></p>
      <p class="text-muted">Dimensions: <strong><%= @board.width %>Ã—<%= @board.height %></strong>, Mines: <strong><%= @board.mines_count %></strong></p>
    </div>
  </div>
</div>

<div class="mt-4">
  <h4>Minesweeper Game</h4>
  
  <div class="game-info mb-3">
    <div class="row">
      <div class="col-auto">
        <span class="badge bg-primary">Mines: <span id="mine-counter"><%= @board.mines_count %></span></span>
      </div>
      <div class="col-auto">
        <span class="badge bg-info">Status: <span id="game-status">Playing</span></span>
      </div>
      <div class="col-auto">
        <button id="reset-btn" class="btn btn-sm btn-success">New Game</button>
      </div>
    </div>
  </div>
  
  <div class="board-container" style="overflow-x: auto;">
    <div id="game-board" class="board-grid" style="
      display: grid;
      grid-template-columns: repeat(<%= @board.width %>, 30px);
      grid-template-rows: repeat(<%= @board.height %>, 30px);
      gap: 1px;
      background-color: #ccc;
      padding: 1px;
      width: fit-content;
      margin: 20px 0;
    ">
      <% JSON.parse(@board.board_data).each_with_index do |row, row_idx| %>
        <% row.each_with_index do |cell, col_idx| %>
          <div 
            class="game-cell" 
            data-row="<%= row_idx %>" 
            data-col="<%= col_idx %>" 
            data-mine="<%= cell['mine'] ? 'true' : 'false' %>"
            style="
              width: 30px;
              height: 30px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 14px;
              font-weight: bold;
              border: 2px outset #ddd;
              background-color: #e9ecef;
              cursor: pointer;
              user-select: none;
            "
          >
          </div>
        <% end %>
      <% end %>
    </div>
  </div>
  
  <div class="mt-3">
    <small class="text-muted">
      Total cells: <%= @board.width * @board.height %> | 
      Mine density: <%= ((@board.mines_count.to_f / (@board.width * @board.height)) * 100).round(1) %>%
    </small>
  </div>
  
  <div class="mt-3">
    <div class="alert alert-info">
      <strong>How to play:</strong>
      <ul class="mb-0">
        <li>Left click to reveal a cell</li>
        <li>Right click to flag/unflag a mine</li>
        <li>Numbers show adjacent mines</li>
        <li>Avoid clicking on mines!</li>
      </ul>
    </div>
  </div>
</div>

<script>
class MinesweeperGame {
  constructor(width, height, totalMines) {
    this.width = width;
    this.height = height;
    this.totalMines = totalMines;
    this.gameStatus = 'playing';
    this.revealedCells = 0;
    this.flaggedMines = 0;
    this.board = [];
    
    this.initializeGame();
    this.attachEventListeners();
  }
  
  initializeGame() {
    // Initialize board state
    this.board = [];
    for (let row = 0; row < this.height; row++) {
      this.board[row] = [];
      for (let col = 0; col < this.width; col++) {
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        this.board[row][col] = {
          isMine: cell.dataset.mine === 'true',
          isRevealed: false,
          isFlagged: false,
          adjacentMines: 0,
          element: cell
        };
      }
    }
    
    // Calculate adjacent mines for each cell
    for (let row = 0; row < this.height; row++) {
      for (let col = 0; col < this.width; col++) {
        if (!this.board[row][col].isMine) {
          this.board[row][col].adjacentMines = this.countAdjacentMines(row, col);
        }
      }
    }
    
    // Reset UI
    this.gameStatus = 'playing';
    this.revealedCells = 0;
    this.flaggedMines = 0;
    this.updateUI();
    this.resetCellStyles();
  }
  
  countAdjacentMines(row, col) {
    let count = 0;
    for (let r = row - 1; r <= row + 1; r++) {
      for (let c = col - 1; c <= col + 1; c++) {
        if (r >= 0 && r < this.height && c >= 0 && c < this.width) {
          if (this.board[r][c].isMine) {
            count++;
          }
        }
      }
    }
    return count;
  }
  
  attachEventListeners() {
    const board = document.getElementById('game-board');
    
    board.addEventListener('click', (e) => {
      if (e.target.classList.contains('game-cell')) {
        e.preventDefault();
        const row = parseInt(e.target.dataset.row);
        const col = parseInt(e.target.dataset.col);
        this.revealCell(row, col);
      }
    });
    
    board.addEventListener('contextmenu', (e) => {
      if (e.target.classList.contains('game-cell')) {
        e.preventDefault();
        const row = parseInt(e.target.dataset.row);
        const col = parseInt(e.target.dataset.col);
        this.toggleFlag(row, col);
      }
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      this.initializeGame();
    });
  }
  
  revealCell(row, col) {
    if (this.gameStatus !== 'playing') return;
    
    const cell = this.board[row][col];
    if (cell.isRevealed || cell.isFlagged) return;
    
    cell.isRevealed = true;
    this.revealedCells++;
    
    if (cell.isMine) {
      this.gameStatus = 'lost';
      this.revealAllMines();
      cell.element.style.backgroundColor = '#dc3545';
      cell.element.style.color = 'white';
      cell.element.textContent = 'ðŸ’¥';
    } else {
      cell.element.style.backgroundColor = '#f8f9fa';
      cell.element.style.border = '1px inset #ddd';
      
      if (cell.adjacentMines > 0) {
        cell.element.textContent = cell.adjacentMines;
        cell.element.style.color = this.getNumberColor(cell.adjacentMines);
      } else {
        cell.element.textContent = '';
        // Auto-reveal adjacent empty cells
        for (let r = row - 1; r <= row + 1; r++) {
          for (let c = col - 1; c <= col + 1; c++) {
            if (r >= 0 && r < this.height && c >= 0 && c < this.width) {
              this.revealCell(r, c);
            }
          }
        }
      }
    }
    
    this.checkWinCondition();
    this.updateUI();
  }
  
  toggleFlag(row, col) {
    if (this.gameStatus !== 'playing') return;
    
    const cell = this.board[row][col];
    if (cell.isRevealed) return;
    
    if (cell.isFlagged) {
      cell.isFlagged = false;
      cell.element.textContent = '';
      cell.element.style.backgroundColor = '#e9ecef';
      this.flaggedMines--;
    } else {
      cell.isFlagged = true;
      cell.element.textContent = 'ðŸš©';
      cell.element.style.backgroundColor = '#fff3cd';
      this.flaggedMines++;
    }
    
    this.updateUI();
  }
  
  revealAllMines() {
    for (let row = 0; row < this.height; row++) {
      for (let col = 0; col < this.width; col++) {
        const cell = this.board[row][col];
        if (cell.isMine && !cell.isRevealed) {
          cell.element.style.backgroundColor = '#dc3545';
          cell.element.style.color = 'white';
          cell.element.textContent = 'ðŸ’£';
        }
      }
    }
  }
  
  checkWinCondition() {
    const totalCells = this.width * this.height;
    const nonMineCells = totalCells - this.totalMines;
    
    if (this.revealedCells === nonMineCells && this.gameStatus === 'playing') {
      this.gameStatus = 'won';
      
      // Auto-flag all remaining mines
      for (let row = 0; row < this.height; row++) {
        for (let col = 0; col < this.width; col++) {
          const cell = this.board[row][col];
          if (cell.isMine && !cell.isFlagged) {
            cell.isFlagged = true;
            cell.element.textContent = 'ðŸš©';
            cell.element.style.backgroundColor = '#d4edda';
          }
        }
      }
    }
  }
  
  getNumberColor(num) {
    const colors = {
      1: '#0000ff',
      2: '#008000',
      3: '#ff0000',
      4: '#800080',
      5: '#800000',
      6: '#008080',
      7: '#000000',
      8: '#808080'
    };
    return colors[num] || '#000000';
  }
  
  resetCellStyles() {
    for (let row = 0; row < this.height; row++) {
      for (let col = 0; col < this.width; col++) {
        const cell = this.board[row][col];
        cell.element.style.backgroundColor = '#e9ecef';
        cell.element.style.border = '2px outset #ddd';
        cell.element.style.color = '#000';
        cell.element.textContent = '';
      }
    }
  }
  
  updateUI() {
    const mineCounter = document.getElementById('mine-counter');
    const gameStatus = document.getElementById('game-status');
    
    mineCounter.textContent = this.totalMines - this.flaggedMines;
    
    if (this.gameStatus === 'won') {
      gameStatus.textContent = 'Won! ðŸŽ‰';
      gameStatus.parentElement.className = 'badge bg-success';
    } else if (this.gameStatus === 'lost') {
      gameStatus.textContent = 'Lost ðŸ’¥';
      gameStatus.parentElement.className = 'badge bg-danger';
    } else {
      gameStatus.textContent = 'Playing';
      gameStatus.parentElement.className = 'badge bg-info';
    }
  }
}

// Initialize the game when page loads
document.addEventListener('DOMContentLoaded', function() {
  const width = <%= @board.width %>;
  const height = <%= @board.height %>;
  const totalMines = <%= @board.mines_count %>;
  
  window.minesweeperGame = new MinesweeperGame(width, height, totalMines);
});
</script>

<div class="mt-4">
  <%= link_to "Back to Home", root_path, class: "btn btn-secondary" %>
  <%= link_to "View All Boards", all_boards_path, class: "btn btn-outline-secondary" %>
  <%= link_to "Generate New Board", root_path, class: "btn btn-primary" %>
</div>